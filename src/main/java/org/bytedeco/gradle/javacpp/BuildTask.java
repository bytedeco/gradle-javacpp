/*
 * Copyright (C) 2020 Samuel Audet
 *
 * Licensed either under the Apache License, Version 2.0, or (at your option)
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation (subject to the "Classpath" exception),
 * either version 2, or any later version (collectively, the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *     http://www.gnu.org/licenses/
 *     http://www.gnu.org/software/classpath/license.html
 *
 * or as provided in the LICENSE.txt file that accompanied this code.
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.bytedeco.gradle.javacpp;

import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.Map;
import java.util.Properties;
import org.bytedeco.javacpp.Loader;
import org.bytedeco.javacpp.tools.Builder;
import org.bytedeco.javacpp.tools.Logger;
import org.bytedeco.javacpp.tools.ParserException;
import org.bytedeco.javacpp.tools.Slf4jLogger;
import org.gradle.api.DefaultTask;
import org.gradle.api.plugins.ExtraPropertiesExtension;
import org.gradle.api.tasks.Classpath;
import org.gradle.api.tasks.Input;
import org.gradle.api.tasks.InputDirectory;
import org.gradle.api.tasks.InputFile;
import org.gradle.api.tasks.InputFiles;
import org.gradle.api.tasks.Optional;
import org.gradle.api.tasks.OutputDirectory;
import org.gradle.api.tasks.TaskAction;

/**
 * A Gradle task that wraps {@link Builder}.
 *
 * @author Samuel Audet
 */
public class BuildTask extends DefaultTask {
    /** Load user classes from classPath. */
    String[] classPath = null;

    /** Add the path to the "platform.includepath" property. */
    String[] includePath = null;

    /** Add the path to the "platform.includeresource" property. */
    String[] includeResource = null;

    /** Add the path to the "platform.buildpath" property. */
    String[] buildPath = null;

    /** Add the path to the "platform.buildresource" property. */
    String[] buildResource = null;

    /** Add the path to the "platform.linkpath" property. */
    String[] linkPath = null;

    /** Add the path to the "platform.linkresource" property. */
    String[] linkResource = null;

    /** Add the path to the "platform.preloadpath" property. */
    String[] preloadPath = null;

    /** Add the path to the "platform.preloadresource" property. */
    String[] preloadResource = null;

    /** Add the path to the "platform.resourcepath" property. */
    String[] resourcePath = null;

    /** Add the path to the "platform.executablepath" property. */
    String[] executablePath = null;

    /** Specify the character encoding used for input and output. */
    String encoding = null;

    /** Output all generated files to outputDirectory. */
    File outputDirectory = null;

    /** Output everything in a file named after given outputName. */
    String outputName = null;

    /** Delete all files from {@link #outputDirectory} before generating anything in it. */
    boolean clean = false;

    /** Generate .cpp files from Java interfaces if found, parsing from header files if not. */
    boolean generate = true;

    /** Compile and delete the generated .cpp files. */
    boolean compile = true;

    /** Delete generated C++ JNI files after compilation */
    boolean deleteJniFiles = true;

    /** Generate header file with declarations of callbacks functions. */
    boolean header = false;

    /** Copy to output directory dependent libraries (link and preload). */
    boolean copyLibs = false;

    /** Copy to output directory resources listed in properties. */
    boolean copyResources = false;

    /** Also create config files for GraalVM native-image in directory. */
    File configDirectory = null;

    /** Also create a JAR file named {@code <jarPrefix>-<platform>.jar}. */
    String jarPrefix = null;

    /** Load all properties from resource. */
    String properties = null;

    /** Load all properties from file. */
    File propertyFile = null;

    /** Set property keys to values. */
    Properties propertyKeysAndValues = null;

    /** Process only these classes or packages (suffixed with .* or .**). */
    String[] classOrPackageNames = null;

    /** Execute a build command instead of JavaCPP itself, and return. */
    String[] buildCommand = null;

    /** Add to Maven project source directory of Java files generated by buildCommand. */
    String[] targetDirectory = null;

    /** Set the working directory of the build subprocess. */
    File workingDirectory = null;

    /** Add environment variables to the compiler subprocess. */
    Map<String,String> environmentVariables = null;

    /** Pass compilerOptions directly to compiler. */
    String[] compilerOptions = null;

    /** Skip the execution. */
    boolean skip = false;

    public BuildTask() {
        // disable incremental builds until we get proper support for them
        getOutputs().upToDateWhen(t -> false);
    }

    @Optional @Classpath
         @InputFiles String[] getClassPath()       { return classPath;       } void setClassPath      (String[] s) { classPath       = s; }
    @Optional @Input String[] getIncludePath()     { return includePath;     } void setIncludePath    (String[] s) { includePath     = s; }
    @Optional @Input String[] getIncludeResource() { return includeResource; } void setIncludeResource(String[] s) { includeResource = s; }
    @Optional @Input String[] getBuildPath()       { return buildPath;       } void setBuildPath      (String[] s) { buildPath       = s; }
    @Optional @Input String[] getBuildResource()   { return buildResource;   } void setBuildResource  (String[] s) { buildResource   = s; }
    @Optional @Input String[] getLinkPath()        { return linkPath;        } void setLinkPath       (String[] s) { linkPath        = s; }
    @Optional @Input String[] getLinkResource()    { return linkResource;    } void setLinkResource   (String[] s) { linkResource    = s; }
    @Optional @Input String[] getPreloadPath()     { return preloadPath;     } void setPreloadPath    (String[] s) { preloadPath     = s; }
    @Optional @Input String[] getPreloadResource() { return preloadResource; } void setPreloadResource(String[] s) { preloadResource = s; }
    @Optional @Input String[] getResourcePath()    { return resourcePath;    } void setResourcePath   (String[] s) { resourcePath    = s; }
    @Optional @Input String[] getExecutablePath()  { return executablePath;  } void setExecutablePath (String[] s) { executablePath  = s; }
    @Optional @Input String   getEncoding()        { return encoding;        } void setEncoding       (String   s) { encoding        = s; }
    @Optional
    @OutputDirectory File     getOutputDirectory() { return outputDirectory; } void setOutputDirectory(File f)     { outputDirectory = f; }
    @Optional @Input String   getOutputName()      { return outputName;      } void setOutputName     (String s)   { outputName      = s; }
              @Input boolean  getClean()           { return clean;           } void setClean          (boolean b)  { clean           = b; }
              @Input boolean  getGenerate()        { return generate;        } void setGenerate       (boolean b)  { generate        = b; }
              @Input boolean  getCompile()         { return compile;         } void setCompile        (boolean b)  { compile         = b; }
              @Input boolean  getDeleteJniFiles()  { return deleteJniFiles;  } void setDeleteJniFiles (boolean b)  { deleteJniFiles  = b; }
              @Input boolean  getHeader()          { return header;          } void setHeader         (boolean b)  { header          = b; }
              @Input boolean  getCopyLibs()        { return copyLibs;        } void setCopyLibs       (boolean b)  { copyLibs        = b; }
              @Input boolean  getCopyResources()   { return copyResources;   } void setCopyResources  (boolean b)  { copyResources   = b; }
    @Optional
    @OutputDirectory File     getConfigDirectory() { return configDirectory; } void setConfigDirectory(File f)     { configDirectory = f; }
    @Optional @Input String   getJarPrefix()       { return jarPrefix;       } void setJarPrefix      (String s)   { jarPrefix       = s; }
    @Optional @Input String   getProperties()      { return properties;      } void setProperties     (String s)   { properties      = s; }
    @Optional @InputFile File getPropertyFile()    { return propertyFile;    } void setPropertyFile   (File f)     { propertyFile    = f; }
    @Optional @Input Properties getPropertyKeysAndValues() { return propertyKeysAndValues; } void setPropertyKeysAndValues(Properties p) { propertyKeysAndValues = p; }
    @Optional @Input String[]   getClassOrPackageNames()   { return classOrPackageNames;   } void setClassOrPackageNames  (String[] s)   { classOrPackageNames   = s; }
    @Optional @Input String[]   getBuildCommand()          { return buildCommand;          } void setBuildCommand         (String[] s)   { buildCommand          = s; }
    @Optional @Input String[]   getTargetDirectory()       { return targetDirectory;       } void setTargetDirectory      (String[] s)   { targetDirectory       = s; }
    @Optional
    @InputDirectory  File       getWorkingDirectory()      { return workingDirectory;      } void setWorkingDirectory     (File f)       { workingDirectory      = f; }
    @Optional @Input Map        getEnvironmentVariables()  { return environmentVariables;  } void setEnvironmentVariables (Map m)        { environmentVariables  = m; }
    @Optional @Input String[]   getCompilerOptions()       { return compilerOptions;       } void setCompilerOptions      (String[] s)   { compilerOptions       = s; }
              @Input boolean    getSkip()                  { return skip;                  } void setSkip                 (boolean b)    { skip                  = b; }

    @TaskAction public void build() throws IOException, ClassNotFoundException, NoClassDefFoundError, InterruptedException, ParserException {
        Logger logger = new Slf4jLogger(Builder.class);

        if (getSkip()) {
            logger.info("Skipping execution of JavaCPP Builder");
            return;
        }

        Builder builder = new Builder(logger)
                .classPaths(getClassPath())
                .encoding(getEncoding())
                .outputDirectory(getOutputDirectory())
                .outputName(getOutputName())
                .clean(getClean())
                .generate(getGenerate())
                .compile(getCompile())
                .deleteJniFiles(getDeleteJniFiles())
                .header(getHeader())
                .copyLibs(getCopyLibs())
                .copyResources(getCopyResources())
                .configDirectory(getConfigDirectory())
                .jarPrefix(getJarPrefix())
                .properties(getProperties())
                .propertyFile(getPropertyFile())
                .properties(getPropertyKeysAndValues())
                .classesOrPackages(getClassOrPackageNames())
                .buildCommand(getBuildCommand())
                .workingDirectory(getWorkingDirectory())
                .environmentVariables(getEnvironmentVariables())
                .compilerOptions(getCompilerOptions())
                .commandExecutor(new BuildExecutor(logger))

                .addProperty("platform.buildpath", getBuildPath())
                .addProperty("platform.buildresource", getBuildResource())
                .addProperty("platform.includepath", getIncludePath())
                .addProperty("platform.includeresource", getIncludeResource())
                .addProperty("platform.linkpath", getLinkPath())
                .addProperty("platform.linkresource", getLinkResource())
                .addProperty("platform.preloadpath", getPreloadPath())
                .addProperty("platform.preloadresource", getPreloadResource())
                .addProperty("platform.resourcepath", getResourcePath())
                .addProperty("platform.executablepath", getExecutablePath());

        String extension = builder.getProperty("platform.extension");
        getLogger().info("Detected platform \"" + Loader.Detector.getPlatform() + "\"");
        getLogger().info("Building platform \"" + builder.getProperty("platform") + "\""
                + (extension != null && extension.length() > 0 ? " with extension \"" + extension + "\"" : ""));

        ExtraPropertiesExtension projectProperties = getProject().getExtensions().getExtraProperties();
        for (String key : builder.getProperties().stringPropertyNames()) {
            projectProperties.set("javacpp." + key, builder.getProperties().getProperty(key));
        }

        File[] outputFiles = builder.build();

        if (getLogger().isDebugEnabled()) {
            getLogger().debug("outputFiles: " + Arrays.deepToString(outputFiles));
        }
    }
}
